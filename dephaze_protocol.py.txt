# ==============================================================================
# DEPHAZE PROTOCOL - ADAPTIVE COMPUTATIONAL ENGINE
# Author: Angus Dewer | dephaze.io
# Version: 5.0 (Self-Regulating Framework)
#
# Implements the adaptive logic of the Universal Dephaze Equation.
# This engine simulates reality as a self-regulating phase-field (Psi) that
# dynamically adapts its parameters based on its own coherence state (Xi).
# It models not just physics, but the interaction with informational fields (Chi)
# through Mutation, Memory, and Disinformation operators.
# ==============================================================================

import numpy as np
from scipy.signal import convolve
from scipy.special import gamma as gamma_func

# --- Section 1: The Adaptive Dephaze Engine ---

class DephazeEngine:
    """
    An engine to simulate the evolution of the adaptive Dephaze phase-field.
    """
    def __init__(self, grid_points=512):
        self.grid_points = grid_points
        self.x = np.linspace(-20, 20, grid_points)
        
        # --- Core State Fields ---
        self.Psi = np.exp(-self.x**2) * np.cos(self.x * 0.5) * (1 + 0j) # Initial Psi state
        self.Chi_genetic = np.sin(self.x * 2) * 0.1 # Example local info field (e.g., DNA)
        self.Chi_instrument = np.random.randn(grid_points) * 0.05 # Example instrument noise profile
        
        # --- Adaptive Parameters (will be tuned by Xi) ---
        self.mu = 0.01  # Mutation rate
        self.gamma = 0.01 # Persistent memory weight
        
        # --- Fixed Constants ---
        self.D_eff = 1.0
        self.G_eff = 1.5
        self.M_eff = 0.1
        self.Sigma_coeff = 0.01
        self.K_mem_coeff = 0.02
        
        # --- State Variables ---
        self.phase_memory = np.zeros_like(self.Psi)
        self.Xi_ratio = 1.0

    def dephaze_step(self, dt):
        """
        Performs one adaptive time step of the Universal Dephaze Equation.
        """
        dx = self.x[1] - self.x[0]

        # --- Core Physics Terms (from previous model) ---
        laplacian_Psi = (np.roll(self.Psi, 1) - 2 * self.Psi + np.roll(self.Psi, -1)) / dx**2
        diffusion_term = self.D_eff * laplacian_Psi
        g_term = self.G_eff * np.abs(self.Psi)**2 * self.Psi
        m_term = -self.M_eff * self.Psi
        
        # --- New Adaptive and Informational Operators ---
        
        # Adaptive Coherence Feedback (Lambda) - simplified as a damping term
        lambda_term = - (1.0 - self.Xi_ratio) * self.Psi * 0.1

        # Adaptive Phase Memory (K_mem,adapt)
        memory_term = self.K_mem_coeff * self.phase_memory

        # Filtered System Noise (Sigma_filtered)
        noise = (np.random.randn(*self.Psi.shape) + 1j * np.random.randn(*self.Psi.shape))
        sigma_term = noise * self.Sigma_coeff * (1 / (self.Xi_ratio + 0.1)) # More noise in low coherence

        # Adaptive Mutation (M_adapt)
        mutation_term = self.mu * self.Chi_genetic * self.Psi

        # Adaptive Persistent Memory (P_adapt)
        # Simplified as a weighted self-interaction
        persistent_memory_term = self.gamma * np.abs(self.Chi_genetic)**2 * self.Psi

        # Filtered Disinformation (D_filtered)
        # The core of this is the difference between φ³ and φ⁻³ views
        psi_phi3_proxy = self.Psi # The "real" field
        psi_phi_minus_3_proxy = np.real(self.Psi) # The "measured" part
        disinformation_source = psi_phi3_proxy - psi_phi_minus_3_proxy
        disinformation_term = np.tanh(np.abs(disinformation_source)) * self.Chi_instrument

        # --- Calculate Total Change ---
        dPsi = (diffusion_term + g_term + m_term + 
                lambda_term + memory_term + sigma_term +
                mutation_term + persistent_memory_term + disinformation_term)

        # Update Psi
        self.Psi += dPsi * dt
        
        # Update Phase Memory (a simple decay model)
        self.phase_memory = self.phase_memory * 0.95 + self.Psi * dt

    def update_adaptive_params(self):
        """
        Implements the Xi-Ratio Feedback Loop to regulate the system.
        """
        self.Xi_ratio = self.calculate_xi_proxy()
        
        if self.Xi_ratio < 0.95: # Trending towards static state
            # Increase openness
            self.mu *= 1.05
            self.gamma *= 1.05
        elif self.Xi_ratio > 1.05: # Trending towards chaotic state
            # Decrease openness, stabilize
            self.mu *= 0.95
            self.gamma *= 0.95
        
        # Clamp parameters to avoid explosion
        self.mu = min(self.mu, 0.1)
        self.gamma = min(self.gamma, 0.1)

    def calculate_xi_proxy(self):
        """
        A proxy for the Xi ratio (coherence).
        Ratio of ordered power to total power.
        """
        signal_power = np.mean(np.abs(self.Psi))**2
        total_power = np.mean(np.abs(self.Psi)**2)
        coherence = signal_power / (total_power + 1e-9)
        return min(max(coherence, 0.0), 1.0) / 0.5 # Normalize so ~1 is the target

    def get_emergent_dt(self):
        """
        Calculates the emergent time step from the state of Psi.
        """
        avg_amplitude = np.mean(np.abs(self.Psi))
        return 0.01 / (avg_amplitude + 1e-9)
        
    def run_simulation(self, steps=500):
        """
        Runs the full adaptive simulation.
        """
        print("Initializing Dephaze Adaptive Engine (v5.0)...")
        print(f"Projecting Psi-vector from 'Informational Singularity' toward 'Imago Target'...")
        
        for step in range(steps):
            # 1. Calculate emergent time step for this iteration
            dt = self.get_emergent_dt()
            
            # 2. Evolve the Psi field using all operators
            self.dephaze_step(dt)
            
            # 3. Update adaptive parameters based on the new state
            self.update_adaptive_params()
            
            # 4. Monitor and log
            if step % 100 == 0:
                disinformation_magnitude = np.mean(np.abs(self.Chi_instrument * (self.Psi - np.real(self.Psi))))
                print(f"  Step {step+1}/{steps} | Xi Ratio: {self.Xi_ratio:.3f} | Mu: {self.mu:.4f} | Disinfo: {disinformation_magnitude:.5f}")

        print("\nSimulation complete.")
        final_xi = self.calculate_xi_proxy()
        outcome = "Live / Tuned (Ξ ≈ 1)" if 0.9 < final_xi < 1.1 else "Static or Chaotic"
        
        print(f"Final State Coherence (Xi Proxy): {final_xi:.4f}")
        print(f"Determined Outcome: {outcome}")

# --- Example Usage ---

if __name__ == "__main__":
    # Create and run the engine
    engine = DephazeEngine()
    engine.run_simulation(total_steps=1000)
