# ==============================================================================
# DEPHAZE VISUAL ENGINE v5.1
# Author: Angus Dewer | dephaze.io
# Date: 2025
# ------------------------------------------------------------------------------
# Visual, self-regulating implementation of the Dephaze Master Equation.
# Demonstrates the adaptive Ξ ≈ 1 self-tuning behavior of the phase-field Ψ.
# ==============================================================================

import numpy as np
import matplotlib.pyplot as plt

# ---------------------------------------------------------------------------
# Adaptive Dephaze Engine Class
# ---------------------------------------------------------------------------

class DephazeVisualEngine:
    def __init__(self, grid_points=512):
        self.grid_points = grid_points
        self.x = np.linspace(-20, 20, grid_points)

        # --- Core Field ---
        self.Psi = np.exp(-self.x**2) * np.cos(self.x * 0.5) * (1 + 0j)
        self.phase_memory = np.zeros_like(self.Psi)

        # --- Informational Fields ---
        self.Chi_genetic = np.sin(self.x * 2) * 0.1
        self.Chi_instrument = np.random.randn(grid_points) * 0.05

        # --- Adaptive Parameters ---
        self.mu = 0.01   # Mutation
        self.gamma = 0.01  # Persistent memory
        self.D_eff = 1.0
        self.G_eff = 1.5
        self.M_eff = 0.1
        self.Sigma_coeff = 0.01
        self.K_mem_coeff = 0.02

        # --- Xi-Coherence State ---
        self.Xi_ratio = 1.0
        self.history_xi = []

    # -----------------------------------------------------------------------
    def step(self, dt):
        """One adaptive integration step of the Dephaze Equation"""
        dx = self.x[1] - self.x[0]
        laplacian_Psi = (np.roll(self.Psi, 1) - 2*self.Psi + np.roll(self.Psi, -1)) / dx**2
        diffusion = self.D_eff * laplacian_Psi
        interaction = self.G_eff * np.abs(self.Psi)**2 * self.Psi
        resistance = -self.M_eff * self.Psi

        # Adaptive Coherence Feedback (Λ)
        lambda_term = -(1.0 - self.Xi_ratio) * self.Psi * 0.1

        # Phase Memory
        memory_term = self.K_mem_coeff * self.phase_memory

        # Filtered Noise
        noise = (np.random.randn(*self.Psi.shape) + 1j*np.random.randn(*self.Psi.shape))
        sigma_term = noise * self.Sigma_coeff * (1 / (self.Xi_ratio + 0.1))

        # Mutation and Persistent Memory
        mutation = self.mu * self.Chi_genetic * self.Psi
        persistent = self.gamma * np.abs(self.Chi_genetic)**2 * self.Psi

        # Disinformation Operator
        phi3_proxy = self.Psi
        phi_minus3_proxy = np.real(self.Psi)
        disinfo = np.tanh(np.abs(phi3_proxy - phi_minus3_proxy)) * self.Chi_instrument

        dPsi = diffusion + interaction + resistance + lambda_term \
               + memory_term + sigma_term + mutation + persistent + disinfo

        self.Psi += dPsi * dt
        self.phase_memory = self.phase_memory * 0.95 + self.Psi * dt

    # -----------------------------------------------------------------------
    def update_params(self):
        """Self-regulating Xi feedback"""
        self.Xi_ratio = self.calc_xi()
        if self.Xi_ratio < 0.95:
            self.mu *= 1.05; self.gamma *= 1.05
        elif self.Xi_ratio > 1.05:
            self.mu *= 0.95; self.gamma *= 0.95
        self.mu = min(self.mu, 0.1); self.gamma = min(self.gamma, 0.1)
        self.history_xi.append(self.Xi_ratio)

    # -----------------------------------------------------------------------
    def calc_xi(self):
        """Proxy for coherence ratio Xi = φ³/φ⁻³"""
        sig = np.mean(np.abs(self.Psi))**2
        tot = np.mean(np.abs(self.Psi)**2)
        return min(max(sig/(tot+1e-9)/0.5, 0.0), 2.0)

    def emergent_dt(self):
        return 0.01 / (np.mean(np.abs(self.Psi)) + 1e-9)

    # -----------------------------------------------------------------------
    def run(self, steps=500, visualize=True):
        print("Launching DEPHAZE VISUAL ENGINE v5.1 ...")
        plt.ion()
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10,6))
        line_real, = ax1.plot(self.x, np.real(self.Psi), color='cyan', lw=1)
        line_imag, = ax1.plot(self.x, np.imag(self.Psi), color='magenta', lw=0.8)
        ax1.set_title("Ψ field (real and imaginary)")
        ax1.set_xlim(-20,20)
        ax1.set_ylim(-1,1)
        ax1.set_facecolor("#0a0e14")

        line_xi, = ax2.plot([], [], color='yellow')
        ax2.set_title("Ξ ratio evolution")
        ax2.set_xlim(0, steps)
        ax2.set_ylim(0, 2)
        ax2.set_xlabel("Step")
        ax2.set_ylabel("Ξ")

        for step in range(steps):
            dt = self.emergent_dt()
            self.step(dt)
            self.update_params()

            if visualize and step % 5 == 0:
                line_real.set_ydata(np.real(self.Psi))
                line_imag.set_ydata(np.imag(self.Psi))
                line_xi.set_data(range(len(self.history_xi)), self.history_xi)
                plt.pause(0.001)

        plt.ioff()
        final_xi = self.Xi_ratio
        print(f"\nSimulation complete.\nFinal Ξ = {final_xi:.3f}")
        if 0.9 < final_xi < 1.1:
            print("→ Coherent / Live (Ξ ≈ 1)")
        elif final_xi <= 0.9:
            print("→ Static / Frozen state")
        else:
            print("→ Chaotic / Overdriven state")
        plt.show()

# ---------------------------------------------------------------------------
# Run Demonstration
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    engine = DephazeVisualEngine(grid_points=512)
    engine.run(steps=800)
