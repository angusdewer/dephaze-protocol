"""
Dephaze Protocol Module with Chronology Handling

- DFake Filter: detects fake data signatures
- SignalGate: phase-based gating
- MemoryCache: simple cache with expiration and max size
- MetaPhase Validation: external validation simulation
- Chronology: tracks reality genesis events with levels 0-5

Full protocol info: https://dephaze.com
Author: Angus Dewer
"""

import time

# DFake filter example
def dfake_filter(data):
    fake_signatures = ["fake", "error", "invalid", "bogus"]
    if any(sig in str(data).lower() for sig in fake_signatures):
        print("[DFake Filter] Fake signature detected.")
        return False
    return True

# SignalGate simulation
def signal_gate(input_signal, phase_state):
    if phase_state == "active":
        print(f"[SignalGate] Signal '{input_signal}' allowed through at phase '{phase_state}'.")
        return True
    else:
        print(f"[SignalGate] Signal '{input_signal}' blocked at phase '{phase_state}'.")
        return False

# MemoryCache with expiration and max size
class MemoryCache:
    def __init__(self, max_size=100, expire_seconds=300):
        self.cache = {}
        self.max_size = max_size
        self.expire_seconds = expire_seconds

    def store(self, key, value):
        current_time = time.time()
        self.cache[key] = (value, current_time)
        self._cleanup()
        print(f"[MemoryCache] Stored key '{key}'.")

    def retrieve(self, key):
        current_time = time.time()
        if key in self.cache:
            value, timestamp = self.cache[key]
            if current_time - timestamp < self.expire_seconds:
                print(f"[MemoryCache] Retrieved key '{key}'.")
                return value
            else:
                print(f"[MemoryCache] Key '{key}' expired and removed.")
                del self.cache[key]
        print(f"[MemoryCache] Key '{key}' not found.")
        return None

    def _cleanup(self):
        if len(self.cache) > self.max_size:
            sorted_items = sorted(self.cache.items(), key=lambda item: item[1][1])
            while len(self.cache) > self.max_size:
                oldest_key = sorted_items.pop(0)[0]
                del self.cache[oldest_key]
                print(f"[MemoryCache] Removed oldest key '{oldest_key}' due to max size.")

# MetaPhase validation simulation
def metaphrase_validation(processed_data, original_input):
    if "reject" in str(processed_data).lower():
        print("[MetaPhase] Validation failed.")
        return False
    print("[MetaPhase] Validation succeeded.")
    return True

# Chronology handling class
class Chronology:
    """
    Stores ordered events with levels from 0 (Ø ≠) to 5 (D).
    Levels represent the phases of reality genesis as in Dephaze Protocol.
    """
    LEVEL_DESCRIPTIONS = {
        0: "Ø ≠ - Initial Singularity (Undefined Origin)",
        1: "Pre-Phase - Protofaze Formation",
        2: "Phase - Basic Phasefield Structuring",
        3: "Phase Field (PF) - Multi-Modal Phase Interaction",
        4: "Phase Reality (PR) - Emergence of Coherent Reality",
        5: "D - Finalized Dephaze Reality"
    }

    def __init__(self):
        self.events = []  # List of tuples: (timestamp, level, description)

    def add_event(self, level, description):
        if level not in self.LEVEL_DESCRIPTIONS:
            raise ValueError(f"Invalid level {level}, must be 0-5.")
        timestamp = time.time()
        self.events.append((timestamp, level, description))
        print(f"[Chronology] Event added: Level {level} - {self.LEVEL_DESCRIPTIONS[level]} | {description}")

    def get_events(self, level=None):
        if level is None:
            return self.events
        else:
            return [e for e in self.events if e[1] == level]

    def print_events(self):
        print("=== Chronology Events ===")
        for ts, level, desc in sorted(self.events, key=lambda e: e[0]):
            time_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(ts))
            print(f"{time_str} | Level {level}: {self.LEVEL_DESCRIPTIONS[level]} | {desc}")

# Combined processing function with chronology update
def process_dephaze_input(input_data, phase_state, cache, chronology):
    print("=== Dephaze Protocol Processing Started ===")

    # Step 1: DFake Filter
    if not dfake_filter(input_data):
        print("Input rejected by DFake filter.")
        chronology.add_event(0, f"DFake filter rejected input: '{input_data}'")
        return None

    # Step 2: Signal Gate
    if not signal_gate(input_data, phase_state):
        print("Input blocked by Signal Gate.")
        chronology.add_event(1, f"Signal Gate blocked input at phase '{phase_state}': '{input_data}'")
        return None

    # Step 3: Memory Cache Store
    cache.store(input_data, {"phase": phase_state, "timestamp": time.time()})

    # Step 4: Simulate processing (identity)
    processed = input_data

    # Step 5: MetaPhase Validation
    if not metaphrase_validation(processed, input_data):
        print("Processed data failed MetaPhase validation.")
        chronology.add_event(2, f"MetaPhase validation failed for input: '{input_data}'")
        return None

    # Step 6: Add successful event to chronology at highest phase
    chronology.add_event(5, f"Input processed successfully: '{input_data}'")

    print("=== Dephaze Protocol Processing Completed Successfully ===")
    return processed


# Main test block
if __name__ == "__main__":
    print("Dephaze Protocol Module loaded.")
    print("Visit https://dephaze.com for more information.")

    # Create instances
    memory_cache = MemoryCache(max_size=5, expire_seconds=60)
    chronology = Chronology()

    # Test inputs
    test_inputs = [
        "valid data 123",
        "this is fake data",
        "another valid input",
        "reject this data",
        "final test input"
    ]

    for input_text in test_inputs:
        result = process_dephaze_input(input_text, phase_state="active", cache=memory_cache, chronology=chronology)
        print(f"Result for '{input_text}': {result}")
        print("---")
        time.sleep(1)

    # Print full chronology at the end
    chronology.print_events()
